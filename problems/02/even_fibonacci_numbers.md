## Problem 2: Even Fibonacci Numbers

From projecteuler.net:

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

I can tell just by the difference in the number of submitted solutions from problem 1 to problem 2 (196830) that this problem is quite a bit more difficult than the first. It seems like the scale of the problem has also increased quite a bit too, instead of solving for numbers up to 1000 we are going up to 4000000. I guess that is the nice part about programming though, you write the code once then if it is quality solution it will be able to handle either number.

I'm going to call this one `evenFibonacciSum` and it will take a parameter `limit` which will be the ceiling to which we want the fibonacci values to be returned. So if I entered `evenFibonacciSum(90)` or `evenFibonacciSum(100)` I would get the same output. Formatting the function this way works well because I have no idea what the closest Fibonacci value to 4 million is, so I will just give the function a ceiliing instead and let the program figure that out itself.

So same as last time, I will start out by writing out the first test for my function. As the problem states above; by starting with 1 and 2 the first ten fibonacci values are 1, 2, 3, 5, 8, 13, 21, 34, 55, 89. The even values in this sequence are 2, 8, and 34, therefore if I called `evenFibonacciSum(100)`, I should get an output of a sum of 44.

```
test('sum of even-valued fibonacci terms whose values do not exceed ninety', () => {
    expect(evenFibonacciSum(100)).toBe(44);
});
```

Breaking this problem into several parts was a necessity from the get-go, on the previous problem it wasn't that hard to just write out the function straight away since its most complex component was a for loop. For this function I started with some pseudocode, breaking the problem down into three main components: Firstly a basic recursive function that returns a fibonacci sequence up to `n`. My second component was sort of a helper function that takes in an upper limit rather than an n value, and returns all of the fibonacci values while the fibonacci sequence output is less than the given limit. The third function takes every fibonacci output up to `n`, pushes all of the even values onto an array and then returns the sum of all of the array values, giving me the correct solution.

To create the fibonacci function using recursion, first you hae to define your base cases which in this case are when `n = 1` and `n = 2`. For every integer after that the function will call itself and the output will be equal to `fibonacci(n-1) + fibonacci(n-2)`:

```
function fibonacci(n) {
    if( n === 1 || n === 2 ) {
      return n;
    } else {
      return fibonacci(n-1) + fibonacci(n-2)
    }
  }

```

This problem got a little messy from the get go as this fibonacci sequence will get called in each of the new functions, and the 3rd function will take the 2nd function as a parameter. Not the most elegant solution but it does give me the correct solution.

The second function is called `fibonacciUpTo` and takes in a limit instead of an `n` value and returns the value of `n` that it takes to reach that ceiling. Since the problem asks for the sum of even values up to 4 million and not the sum of even values for the first X fibonacci values this was a necessary conversion to keep the formatting of the function in line with the problem.

```
function fibonacciUpTo(limit) {
    var n = 1;
    while ( fibonacci(n) < limit ) {
      n++;
    }
    var int = n - 1;
    return int
}
```

The third function `evenFibonacciSum` takes the n value from `fibonacciUpTo` and creates an array of the even fibonacci values up to that `n` value, then adds them up and gives us a value `sum` that returns the answer to the problem. So while the function says `evenFibonacciSum(n)`, `evenFibonacciSum(fibonacciUpTo(limit))` is actually a much more accurate representation.

```
function evenFibonacciSum(n) {
    var arr = [];
    for ( var i = 1; i <= n; i++ ) {
        if ( fibonacci(i) % 2 === 0 ){
        arr.push( fibonacci(i) );
        }
    }
    var sum = arr.reduce( (a, b) => a + b, 0 )
    return sum;
}
```

So since there are nested functions in our code, the tests will not run properly unless we make some changes so we do not get error messages.

```
test('sum of even-valued fibonacci terms whose values do not exceed one hundred', () => {
    function fibonacci(n) {
        if( n === 1 || n === 2 ) {
          return n;
        } else {
          return fibonacci(n-1) + fibonacci(n-2)
        }
      }

      function fibonacciUpTo(limit) {
        var n = 1;
        while ( fibonacci(n) < limit ) {
        n++;
        }
        var int = n - 1;
        return int
    }

    expect(evenFibonacciSum(fibonacciUpTo(100))).toBe(44);
});
```

This test returns a pass, so to get the answer to the problem I call `evenFibonacciSum(fibonacciUpTo(4000000))` which returns an output of 4613732, which is the correct answer. This means that my not very elegant, pretty messy solution, does solve the problem with the correct outputs. Which is nice.
